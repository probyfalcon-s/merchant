{"name": "test_send_usdt_transaction", "status": "failed", "statusDetails": {"message": "Failed: ❌ RPC ошибка: {'code': -32000, 'message': 'insufficient funds for gas * price + value: balance 187368540891544, tx cost 400000000000000, overshot 212631459108456'}", "trace": "def test_send_usdt_transaction():\n        web3 = Web3(Web3.HTTPProvider(MAINNET_RPC))\n        assert web3.is_connected(), \"❌ Нет подключения к BNB mainnet\"\n    \n        sender = web3.to_checksum_address(SENDER_ADDRESS)\n        recipient = web3.to_checksum_address(RECIPIENT_ADDRESS)\n        token_contract = web3.eth.contract(address=web3.to_checksum_address(USDT_CONTRACT_ADDRESS), abi=ERC20_ABI)\n    \n        amount = 0.01 #кол-во USDT\n        decimals = 18  # ⚠️  точность, зависит от USDT (либо 6 на mainnet)\n        amount_wei = int(amount * 10**decimals)\n    \n        nonce = web3.eth.get_transaction_count(sender, 'pending')\n    \n        base_gas_price = web3.to_wei('10', 'gwei')\n        max_gas_price = web3.to_wei('50', 'gwei')\n        step_gas_price = web3.to_wei('2', 'gwei')\n    \n        while base_gas_price <= max_gas_price:\n            try:\n                tx = token_contract.functions.transfer(\n                    recipient,\n                    amount_wei\n                ).build_transaction({\n                    'from': sender,\n                    'nonce': nonce,\n                    'gas': 40000,\n                    'gasPrice': base_gas_price,\n                    'chainId': 56\n                })\n    \n                signed_tx = web3.eth.account.sign_transaction(tx, private_key=PRIVATE_KEY)\n>               tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)\n\ntests/test_deposit_usdt_web3.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n../.venv/lib/python3.12/site-packages/web3/eth/eth.py:397: in send_raw_transaction\n    return self._send_raw_transaction(transaction)\n../.venv/lib/python3.12/site-packages/web3/module.py:112: in caller\n    result = w3.manager.request_blocking(\n../.venv/lib/python3.12/site-packages/web3/manager.py:232: in request_blocking\n    return self.formatted_response(\n../.venv/lib/python3.12/site-packages/web3/manager.py:198: in formatted_response\n    validate_rpc_response_and_raise_if_error(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nresponse = {'error': {'code': -32000, 'message': 'insufficient funds for gas * price + value: balance 187368540891544, tx cost 400000000000000, overshot 212631459108456'}, 'id': 2, 'jsonrpc': '2.0'}\nerror_formatters = <cyfunction identity at 0x1041a0ee0>, is_subscription_response = False, logger = <Logger web3.manager.RequestManager (WARNING)>\nparams = ('0xf8aa5b8502540be400829c409455d398326f99059ff775485246999027b319795580b844a9059cbb000000000000000000000000cc9316f79e...3263eca0fa768241172c22643e001f1276ef541c4127fa092fa023bc0c8e950a606b4d038e2b222360a99dda7cff5dc9b12f1dc413586946c460',)\n\n    def validate_rpc_response_and_raise_if_error(\n        response: RPCResponse,\n        error_formatters: Optional[Callable[..., Any]],\n        is_subscription_response: bool = False,\n        logger: Optional[logging.Logger] = None,\n        params: Optional[Any] = None,\n    ) -> None:\n        if \"jsonrpc\" not in response or response[\"jsonrpc\"] != \"2.0\":\n            _raise_bad_response_format(\n                response, 'The \"jsonrpc\" field must be present with a value of \"2.0\".'\n            )\n    \n        response_id = response.get(\"id\")\n        if \"id\" in response:\n            int_error_msg = (\n                '\"id\" must be an integer or a string representation of an integer.'\n            )\n            if response_id is None and \"error\" in response:\n                # errors can sometimes have null `id`, according to the JSON-RPC spec\n                pass\n            elif not isinstance(response_id, (str, int)):\n                _raise_bad_response_format(response, int_error_msg)\n            elif isinstance(response_id, str):\n                try:\n                    int(response_id)\n                except ValueError:\n                    _raise_bad_response_format(response, int_error_msg)\n        elif is_subscription_response:\n            # if `id` is not present, this must be a subscription response\n            _validate_subscription_fields(response)\n        else:\n            _raise_bad_response_format(\n                response,\n                'Response must include an \"id\" field or be formatted as an '\n                \"`eth_subscription` response.\",\n            )\n    \n        if all(key in response for key in {\"error\", \"result\"}):\n            _raise_bad_response_format(\n                response, 'Response cannot include both \"error\" and \"result\".'\n            )\n        elif (\n            not any(key in response for key in {\"error\", \"result\"})\n            and not is_subscription_response\n        ):\n            _raise_bad_response_format(\n                response, 'Response must include either \"error\" or \"result\".'\n            )\n        elif \"error\" in response:\n            web3_rpc_error: Optional[Web3RPCError] = None\n            error = response[\"error\"]\n    \n            # raise the error when the value is a string\n            if error is None or not isinstance(error, dict):\n                _raise_bad_response_format(\n                    response,\n                    'response[\"error\"] must be a valid object as defined by the '\n                    \"JSON-RPC 2.0 specification.\",\n                )\n    \n            # errors must include a message\n            error_message = error.get(\"message\")\n            if not isinstance(error_message, str):\n                _raise_bad_response_format(\n                    response, 'error[\"message\"] is required and must be a string value.'\n                )\n            elif error_message == \"transaction not found\":\n                transaction_hash = params[0]\n                web3_rpc_error = TransactionNotFound(\n                    repr(error),\n                    rpc_response=response,\n                    user_message=(f\"Transaction with hash {transaction_hash!r} not found.\"),\n                )\n    \n            # errors must include an integer code\n            code = error.get(\"code\")\n            if not isinstance(code, int):\n                _raise_bad_response_format(\n                    response, 'error[\"code\"] is required and must be an integer value.'\n                )\n            elif code == METHOD_NOT_FOUND:\n                web3_rpc_error = MethodUnavailable(\n                    repr(error),\n                    rpc_response=response,\n                    user_message=(\n                        \"This method is not available. Check your node provider or your \"\n                        \"client's API docs to see what methods are supported and / or \"\n                        \"currently enabled.\"\n                    ),\n                )\n            elif any(\n                # parse specific timeout messages\n                timeout_str in error_message.lower()\n                for timeout_str in KNOWN_REQUEST_TIMEOUT_MESSAGING\n            ):\n                web3_rpc_error = RequestTimedOut(\n                    repr(error),\n                    rpc_response=response,\n                    user_message=(\n                        \"The request timed out. Check the connection to your node and \"\n                        \"try again.\"\n                    ),\n                )\n    \n            if web3_rpc_error is None:\n                # if no condition was met above, raise a more generic `Web3RPCError`\n                web3_rpc_error = Web3RPCError(repr(error), rpc_response=response)\n    \n            response = apply_error_formatters(error_formatters, response)\n            if logger is not None:\n                logger.debug(\"RPC error response: %s\", response)\n    \n>           raise web3_rpc_error\nE           web3.exceptions.Web3RPCError: {'code': -32000, 'message': 'insufficient funds for gas * price + value: balance 187368540891544, tx cost 400000000000000, overshot 212631459108456'}\n\n../.venv/lib/python3.12/site-packages/web3/_utils/validation.py:401: Web3RPCError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_send_usdt_transaction():\n        web3 = Web3(Web3.HTTPProvider(MAINNET_RPC))\n        assert web3.is_connected(), \"❌ Нет подключения к BNB mainnet\"\n    \n        sender = web3.to_checksum_address(SENDER_ADDRESS)\n        recipient = web3.to_checksum_address(RECIPIENT_ADDRESS)\n        token_contract = web3.eth.contract(address=web3.to_checksum_address(USDT_CONTRACT_ADDRESS), abi=ERC20_ABI)\n    \n        amount = 0.01 #кол-во USDT\n        decimals = 18  # ⚠️  точность, зависит от USDT (либо 6 на mainnet)\n        amount_wei = int(amount * 10**decimals)\n    \n        nonce = web3.eth.get_transaction_count(sender, 'pending')\n    \n        base_gas_price = web3.to_wei('10', 'gwei')\n        max_gas_price = web3.to_wei('50', 'gwei')\n        step_gas_price = web3.to_wei('2', 'gwei')\n    \n        while base_gas_price <= max_gas_price:\n            try:\n                tx = token_contract.functions.transfer(\n                    recipient,\n                    amount_wei\n                ).build_transaction({\n                    'from': sender,\n                    'nonce': nonce,\n                    'gas': 40000,\n                    'gasPrice': base_gas_price,\n                    'chainId': 56\n                })\n    \n                signed_tx = web3.eth.account.sign_transaction(tx, private_key=PRIVATE_KEY)\n                tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)\n    \n                print(f\"✅ USDT транзакция отправлена: {web3.to_hex(tx_hash)}\")\n                receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)\n    \n                assert receipt.status == 1, \"❌ Транзакция завершилась с ошибкой\"\n                break\n    \n            except Web3RPCError as e:\n                msg = str(e)\n                if 'underpriced' in msg or 'already known' in msg:\n                    print(f\"⚠️ {msg} — увеличиваем gasPrice...\")\n                    base_gas_price += step_gas_price\n                    time.sleep(1)\n                else:\n>                   pytest.fail(f\"❌ RPC ошибка: {msg}\")\nE                   Failed: ❌ RPC ошибка: {'code': -32000, 'message': 'insufficient funds for gas * price + value: balance 187368540891544, tx cost 400000000000000, overshot 212631459108456'}\n\ntests/test_deposit_usdt_web3.py:76: Failed"}, "start": 1759746766210, "stop": 1759746766650, "uuid": "f6568d51-3c11-411d-87ea-f23c9695bbb7", "historyId": "68ac6b800b3c47733fe6dc5f30268faa", "testCaseId": "68ac6b800b3c47733fe6dc5f30268faa", "fullName": "tests.test_deposit_usdt_web3#test_send_usdt_transaction", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_deposit_usdt_web3"}, {"name": "host", "value": "mac-falcon.local"}, {"name": "thread", "value": "47808-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_deposit_usdt_web3"}]}